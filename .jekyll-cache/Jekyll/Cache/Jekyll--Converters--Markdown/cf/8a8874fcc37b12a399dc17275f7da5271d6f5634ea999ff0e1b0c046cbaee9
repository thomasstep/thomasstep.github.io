I"†<p><a href="https://thomasstep.dev/blog/i-built-and-published-an-iphone-app">Iâ€™ve been working on developing an iOS 14 app in my free time lately</a>, and the other day I wanted to create a <code class="language-plaintext highlighter-rouge">TextField</code> to receive input from the user. I needed a number, so <a href="URL FOR KEYPAD POST">I changed the <code class="language-plaintext highlighter-rouge">keyboardType</code> to <code class="language-plaintext highlighter-rouge">numberPad</code> and added some validation logic</a>. Everything was fairly easy to set up especially considering I have never developed on iOS before or written code in objective C. Then came the doozy. Whenever I tapped on something other than the <code class="language-plaintext highlighter-rouge">TextField</code>, nothing happened. I expected the keyboard to go away but it didnâ€™t want to budge. Every app I have ever used had this behavior, so I assumed that it was the built-in default behavior. I was wrong. I went down rabbit hole after rabbit hole trying to figure out how to hide the keyboard. Most of the problems I encountered were due to blog posts and StackOverflow answers referring to earlier versions of iOS, and since I was developing for iOS 14, all of my code and views were written differently. (Again, I have never developed for iOS before. It is very well possible that I am completely wrong and I could have solved this much quicker with any of the other snippets out on the internet.) It turns out that the behavior of hiding a keyboard when a <code class="language-plaintext highlighter-rouge">TextField</code> becomes unfocused is not natively built into Swift. The alternative that I ended up going with was extending <code class="language-plaintext highlighter-rouge">View</code> with a function that sends an action to <code class="language-plaintext highlighter-rouge">resignFirstResponder</code>. Then I added <code class="language-plaintext highlighter-rouge">onTapGesture</code> to a view that encompassed the screen where the keyboard showed up and called the function as a result. The whole process is still a little weird to me, but it has started to make more sense the more I look at it. Hereâ€™s an example of the code.</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if canImport(UIKit)</span>
<span class="kd">extension</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">hideKeyboard</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
        <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">sendAction</span><span class="p">(</span><span class="kd">#selector(</span><span class="nf">UIResponder.resignFirstResponder</span><span class="kd">)</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">myInput</span> <span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>

  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">ScrollView</span> <span class="p">{</span>
      <span class="kt">TextField</span><span class="p">(</span><span class="s">"Demo text field"</span><span class="p">,</span> <span class="nv">text</span><span class="p">:</span> <span class="err">$</span><span class="n">myInput</span><span class="p">)</span>
          <span class="o">.</span><span class="nf">multilineTextAlignment</span><span class="p">(</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
          <span class="o">.</span><span class="nf">textFieldStyle</span><span class="p">(</span><span class="kt">RoundedBorderTextFieldStyle</span><span class="p">())</span>
          <span class="o">.</span><span class="nf">keyboardType</span><span class="p">(</span><span class="o">.</span><span class="n">numberPad</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">onTapGesture</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">perform</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">hideKeyboard</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I think the key here for me is that <code class="language-plaintext highlighter-rouge">ScrollView</code> takes up the entire screen of my app, so when I added the listener, if the user tapped anywhere else on the screen, they would experience the desired behavior. Since this is not natively built into Swift, I have to assume that there is no standard way of doing this. Not using this behavior as a default seems like a huge oversight to me, and I wish there was an Apple-approved way of writing in this behavior.</p>
:ET