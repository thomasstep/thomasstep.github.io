I"J&<p>A while back, I was attempting to block access to a secret in AWS Secrets Manager to everything except a few IAM Roles and Users. It might seem like an easy task but there were some challenges involved. I will include a snippet of a template to go over the different parts, but if you would rather just snag a copy of the whole template, I have added it to my <a href="https://github.com/thomasstep/aws-cloudformation-reference/blob/master/secretsmanager/whitelisted-secret.yml">aws-cloudformation-reference GitHub repo</a> along with other CloudFormation templates that I have created as a reference point. The following is a version of the resource policy attached to the Secret which allows access to specific IAM Roles and Users.</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">Parameters</span><span class="pi">:</span>
  <span class="na">WhitelistedRoleIds</span><span class="pi">:</span>
    <span class="na">Type</span><span class="pi">:</span> <span class="s">CommaDelimitedList</span>
    <span class="na">Description</span><span class="pi">:</span> <span class="pi">&gt;</span>
      <span class="s">IDs (AROA*, or AIDA*) to whitelist access for on the created secret.</span>
      <span class="s">Find the Role ID by running aws iam get-role --role-name ROLE-NAME.</span>
      <span class="s">Remember to append :* to the end of the Role IDs.</span>
      <span class="s">Find the User ID by running aws iam get-user --user-name USER-NAME.</span>
      <span class="s">User IDs do not need :* appended to the end.</span>

<span class="na">Resources</span><span class="pi">:</span>
  <span class="s">...</span>
  <span class="s">SecretResourcePolicy</span><span class="pi">:</span>
    <span class="na">Type</span><span class="pi">:</span> <span class="s1">'</span><span class="s">AWS::SecretsManager::ResourcePolicy'</span>
    <span class="na">Properties</span><span class="pi">:</span>
        <span class="na">SecretId</span><span class="pi">:</span> <span class="kt">!Ref</span> <span class="s">MySecret</span>
        <span class="na">ResourcePolicy</span><span class="pi">:</span>
          <span class="na">Version</span><span class="pi">:</span> <span class="s">2012-10-17</span>
          <span class="na">Statement</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">Resource</span><span class="pi">:</span> <span class="kt">!Ref</span> <span class="s">MySecret</span>
              <span class="na">Action</span><span class="pi">:</span> <span class="s1">'</span><span class="s">secretsmanager:GetSecretValue'</span>
              <span class="na">Effect</span><span class="pi">:</span> <span class="s">Deny</span>
              <span class="na">Principal</span><span class="pi">:</span> <span class="s1">'</span><span class="s">*'</span>
              <span class="na">Condition</span><span class="pi">:</span>
                <span class="na">StringNotLike</span><span class="pi">:</span>
                  <span class="s">aws:userId: !Ref WhitelistedRoleIds</span>
</code></pre></div></div>

<p>There are some nuances worth pointing out that I stumbled across while figuring out this configuration.</p>

<p>First, I want to lay the foundation with resource policies. I had existing knowledge when I came across this problem (although not much hands-on experience) that some AWS resources allow us to attach resource policies to them. Some of those other resources include S3 and Lambda (for a huge list <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html">check out this page</a> under the “Resource-based policies” column).</p>

<p>Resource policies allow us to <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html#policy-eval-denyallow">create a shortcut for access and denial</a> based on a few key properties that are available in most API calls to the resource. This means that even if an IAM Role explicitly allows access to a certain resource, the resource policy can explicitly deny that Role access thereby denying the resource that assumed the Role. The same is true the other way around, an IAM Role that denies access to a resource will be overridden if a resource policy explicitly grants access.</p>

<p>I try to simplify this in my mind by thinking that whatever rules are closest to the resource win. An IAM Role can be a general thing, but a resource policy is directly attached to a resource. That means the rules on the resource policy win out over the IAM Role every time.</p>

<p>Building on top of our resource policy knowledge, we start getting into the nuts and bolts of this specific Secrets Manager resource policy. Since we want to create a whitelist and blacklist all other IAM resources, we’ll need an explicit deny on everything except those whitelisting resources. Unfortunately, we can’t simplify this to an explicit deny on everything in one statement and then another statement that gives an explicit allow. The way that the rules prioritize themselves would give precedence to the “deny everything”.</p>

<p>Now that we understand what resource policies are, the next step is understanding what type of properties are available in API calls to the Secret according to which we can grant or deny access. The first and most obvious resource policy configuration type that I tried to use was <code class="language-plaintext highlighter-rouge">NotPrincipal</code>. This is similar to the <code class="language-plaintext highlighter-rouge">Principal</code> that sits in the aforementioned resource policy <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notprincipal.html#specifying-notprincipal">except it does the opposite</a>. I set out attempting to accomplish the same goal but using <code class="language-plaintext highlighter-rouge">NotPrincipal</code>, which I hoped would look like the following.</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">Resource</span><span class="pi">:</span> <span class="kt">!Ref</span> <span class="s">MySecret</span>
  <span class="na">Action</span><span class="pi">:</span> <span class="s1">'</span><span class="s">secretsmanager:GetSecretValue'</span>
  <span class="na">Effect</span><span class="pi">:</span> <span class="s">Deny</span>
  <span class="na">NotPrincipal</span><span class="pi">:</span>
    <span class="na">AWS</span><span class="pi">:</span> <span class="kt">!Ref</span> <span class="s">WhitelistedPrincipals</span>
</code></pre></div></div>

<p>Unfortunately, when an API call comes in from an assumed IAM Role, it no longer looks like <code class="language-plaintext highlighter-rouge">arn:aws:sts::AWS_ACCOUNT_ID:assumed-role/ROLE_NAME/SESSION_NAME</code> which is also referred to as the assumed role ARN. Since the <code class="language-plaintext highlighter-rouge">Principal</code> is made up of both the IAM Role’s ARN and the assumed role ARN, IAM will deny access to the resource since the <code class="language-plaintext highlighter-rouge">Principal</code> does not match exactly.</p>

<p><code class="language-plaintext highlighter-rouge">aws:userId</code> incoming. After much scouring, I eventually landed on a page <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-userid">listing the IAM policy condition keys</a>. This was part one. Part two was a <a href="https://aws.amazon.com/blogs/security/how-to-restrict-amazon-s3-bucket-access-to-a-specific-iam-role/">blog post about restricting access to an S3 bucket</a> similarly to what I wanted to do with my Secret. The post explains that an IAM Role that has been assumed will always pass the same Role ID in the <code class="language-plaintext highlighter-rouge">aws:userId</code> variable along with the session name. I like to think of that unique Role ID as some mixture of the IAM Role ARN and the assumed role ARN. Since it is a singular variable, we can grant access based on it in the resource policy.</p>

<p>In case anyone is curious, <code class="language-plaintext highlighter-rouge">AROA*</code> and <code class="language-plaintext highlighter-rouge">AIDA*</code> are <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-unique-ids">unique prefixes that are predefined by AWS</a>. I remember noticing that pattern while looking through logs about something unrelated and wondering if they all meant something. Turns out they do.</p>

<p>Using the <code class="language-plaintext highlighter-rouge">aws:userId</code> variable allows us to whitelist both IAM Users and Roles. An IAM Role needs to be whitelisted as something like <code class="language-plaintext highlighter-rouge">AROAJQABLZS4A3QDU576Q:*</code> because the session name is appended onto the Role ID at the end. (Roles must be assumed first before making an API call.) An IAM User needs to be whitelisted as something like <code class="language-plaintext highlighter-rouge">AIDAJQABLZS4A3QDU576Q</code> without the <code class="language-plaintext highlighter-rouge">:*</code> appended. To find those funky-looking IDs, run <code class="language-plaintext highlighter-rouge">aws iam get-role --role-name ROLE_NAME</code> or <code class="language-plaintext highlighter-rouge">aws iam get-user --user-name USER_NAME</code>.</p>

<p>I had to go down quite a few rabbit holes to figure this one out, which is why it warranted a story instead of a simple snippet. For anyone out there that might run across this and need more help, feel free to reach out to me and I will do what I can!</p>
:ET